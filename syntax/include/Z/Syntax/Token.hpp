#ifndef Z_SYNTAX_TOKEN_HPP
#define Z_SYNTAX_TOKEN_HPP

#include <cstdint>
#include <optional>
#include <string>
#include <unordered_map>

namespace Z {
namespace Syntax {
/**
 * Type of token for lexical analysis.
 */
enum class TokenKind {
  Dummy = -2,
  Eof = -1,
  Plus = 1,
  Minus,
  Asterisk,
  Slash,
  Percent,
  Pipe,
  Amp,
  Equal,
  Exclam,
  Tilde,
  Caret,

  LParen,
  RParen,
  LBrak,
  RBrak,
  LBrace,
  RBrace,

  Dot,
  Comma,
  Colon,
  Semicolon,

  PlusPlus,
  MinusMinus,
  AmpAmp,
  PipePipe,

  Lesser,
  LesserEqual,
  LesserLesser,
  Greater,
  GreaterEqual,
  GreaterGreater,

  PlusEqual,
  MinusEqual,
  AsteriskEqual,
  SlashEqual,
  PercentEqual,
  AmpEqual,
  PipeEqual,
  EqualEqual,
  ExclamEqual,

  GreaterGreaterEqual,
  LesserLesserEqual,

  Arrow,
  EqualBig,

  ColonEqual,

  Numeric,
  String,
  Identifier,

  Null,
  True,
  False,
  Let,
  Type,
  Alias,
  Import,
  Export,
  Return,
  Struct,
  Enum,
  Alloc,
  If,
  EndIf,
  Loop,
  EndLoop,
  Lamb,
  Func,
  Vari,
  View,
  Job,
  Yield,
  Fiber,
  Serial,
  Parallel,
  Lock,
  Unlock,
  Swap,
  Flush,
  Shared,
  Break,
  Continue,
  Goto,
};

const std::unordered_map<std::string, TokenKind> Keywords = {
    {"null", TokenKind::Null},
    {"true", TokenKind::True},
    {"false", TokenKind::False},
    {"let", TokenKind::Let},
    {"type", TokenKind::Type},
    {"alias", TokenKind::Alias},
    {"import", TokenKind::Import},
    {"export", TokenKind::Export},
    {"return", TokenKind::Return},
    {"struct", TokenKind::Struct},
    {"enum", TokenKind::Enum},
    {"alloc", TokenKind::Alloc},
    {"if", TokenKind::If},
    {"endif", TokenKind::EndIf},
    {"loop", TokenKind::Loop},
    {"endloop", TokenKind::EndLoop},
    {"lamb", TokenKind::Lamb},
    {"func", TokenKind::Func},
    {"vari", TokenKind::Vari},
    {"view", TokenKind::View},
    {"job", TokenKind::Job},
    {"yield", TokenKind::Yield},
    {"fiber", TokenKind::Fiber},
    {"serial", TokenKind::Serial},
    {"parallel", TokenKind::Parallel},
    {"lock", TokenKind::Lock},
    {"unlock", TokenKind::Unlock},
    {"swap", TokenKind::Swap},
    {"flush", TokenKind::Flush},
    {"shared", TokenKind::Shared},
    {"break", TokenKind::Break},
    {"continue", TokenKind::Continue},
    {"goto", TokenKind::Goto},
};

const std::unordered_map<TokenKind, std::string> TokenString = {
    {TokenKind::Dummy, "Dummy"},
    {TokenKind::Eof, "Eof"},
    {TokenKind::Plus, "+"},
    {TokenKind::Minus, "-"},
    {TokenKind::Asterisk, "*"},
    {TokenKind::Slash, "/"},
    {TokenKind::Percent, "%"},
    {TokenKind::Pipe, "|"},
    {TokenKind::Amp, "&"},
    {TokenKind::Equal, "="},
    {TokenKind::Exclam, "!"},
    {TokenKind::Tilde, "~"},
    {TokenKind::Caret, "^"},
    {TokenKind::LParen, "LParen"},
    {TokenKind::RParen, "RParen"},
    {TokenKind::LBrak, "LBrak"},
    {TokenKind::RBrak, "RBrak"},
    {TokenKind::LBrace, "LBrace"},
    {TokenKind::RBrace, "RBrace"},
    {TokenKind::Dot, "Dot"},
    {TokenKind::Comma, "Comma"},
    {TokenKind::Colon, ":"},
    {TokenKind::Semicolon, "Semicolon"},
    {TokenKind::PlusPlus, "PlusPlus"},
    {TokenKind::MinusMinus, "MinusMinus"},
    {TokenKind::AmpAmp, "AmpAmp"},
    {TokenKind::PipePipe, "PipePipe"},
    {TokenKind::Lesser, "Lesser"},
    {TokenKind::LesserEqual, "LesserEqual"},
    {TokenKind::LesserLesser, "LesserLesser"},
    {TokenKind::Greater, "Greater"},
    {TokenKind::GreaterEqual, "GreaterEqual"},
    {TokenKind::GreaterGreater, "GreaterGreater"},
    {TokenKind::PlusEqual, "PlusEqual"},
    {TokenKind::MinusEqual, "MinusEqual"},
    {TokenKind::AsteriskEqual, "AsteriskEqual"},
    {TokenKind::SlashEqual, "SlashEqual"},
    {TokenKind::PercentEqual, "PercentEqual"},
    {TokenKind::AmpEqual, "AmpEqual"},
    {TokenKind::PipeEqual, "PipeEqual"},
    {TokenKind::EqualEqual, "EqualEqual"},
    {TokenKind::ExclamEqual, "ExclamEqual"},
    {TokenKind::GreaterGreaterEqual, "GreaterGreaterEqual"},
    {TokenKind::LesserLesserEqual, "LesserLesserEqual"},
    {TokenKind::Arrow, "Arrow"},
    {TokenKind::EqualBig, "EqualBig"},
    {TokenKind::ColonEqual, ":="},
    {TokenKind::Numeric, "Numeric"},
    {TokenKind::String, "String"},
    {TokenKind::Identifier, "Identifier"},
    {TokenKind::Null, "Null"},
    {TokenKind::True, "True"},
    {TokenKind::False, "False"},
    {TokenKind::Let, "Let"},
    {TokenKind::Type, "Type"},
    {TokenKind::Alias, "Alias"},
    {TokenKind::Import, "Import"},
    {TokenKind::Export, "Export"},
    {TokenKind::Return, "Return"},
    {TokenKind::Struct, "Struct"},
    {TokenKind::Enum, "Enum"},
    {TokenKind::Alloc, "Alloc"},
    {TokenKind::If, "If"},
    {TokenKind::EndIf, "EndIf"},
    {TokenKind::Loop, "Loop"},
    {TokenKind::EndLoop, "EndLoop"},
    {TokenKind::Lamb, "Lamb"},
    {TokenKind::Func, "Func"},
    {TokenKind::Vari, "Vari"},
    {TokenKind::View, "View"},
    {TokenKind::Job, "Job"},
    {TokenKind::Yield, "Yield"},
    {TokenKind::Fiber, "Fiber"},
    {TokenKind::Serial, "Serial"},
    {TokenKind::Parallel, "Parallel"},
    {TokenKind::Lock, "Lock"},
    {TokenKind::Unlock, "Unlock"},
    {TokenKind::Swap, "Swap"},
    {TokenKind::Flush, "Flush"},
    {TokenKind::Shared, "Shared"},
    {TokenKind::Break, "Break"},
    {TokenKind::Continue, "Continue"},
    {TokenKind::Goto, "Goto"},
};

struct PosInfo {
  std::size_t start;
  std::size_t end;
};

struct Token {
  TokenKind kind;
  PosInfo position;

  Token(TokenKind kind, size_t start, size_t end)
      : kind(kind), position({
                        .start = start,
                        .end = end,
                    }) {}
};
}; // namespace Syntax
}; // namespace Z

#endif // Z_SYNTAX_TOKEN_HPP
